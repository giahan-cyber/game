<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Vocab Adventure v2 (KR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --panel-soft: #020617;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.18);
      --accent-strong: #22c55e;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
      --border-subtle: rgba(148, 163, 184, 0.35);
      --tile: rgba(15, 23, 42, 0.95);
      --tile-alt: rgba(15, 23, 42, 0.85);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, #0f172a 0, rgba(15,23,42,0.85) 35%, #000 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .game {
      width: 100%;
      max-width: 1080px;
      border-radius: 24px;
      padding: 16px 18px 18px;
      background:
        radial-gradient(circle at top left, rgba(37,99,235,0.4), rgba(15,23,42,0.96));
      border: 1px solid rgba(59, 130, 246, 0.5);
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(15, 23, 42, 0.7);
      backdrop-filter: blur(18px);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    .title-block h1 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.04em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-pill {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--accent-strong);
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid var(--accent-soft);
      background:
        radial-gradient(circle at top left, rgba(59,130,246,0.5), transparent);
    }

    .subtitle {
      margin: 4px 0 0;
      font-size: 0.82rem;
      color: var(--muted);
      max-width: 480px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--muted);
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(15, 23, 42, 0.96);
    }

    .pill span {
      opacity: 0.9;
    }

    #restart-btn {
      border: none;
      padding: 6px 14px;
      border-radius: 999px;
      background:
        radial-gradient(circle at top left, #3b82f6, #22c55e);
      color: #ecfeff;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(59,130,246,0.6),
        0 14px 32px rgba(30, 64, 175, 0.9);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      display: none;
    }

    #restart-btn:hover {
      transform: translateY(-1px);
      box-shadow:
        0 0 0 1px rgba(96,165,250,0.9),
        0 18px 40px rgba(30, 64, 175, 0.95);
    }

    main.board {
      display: grid;
      grid-template-columns: minmax(0, 1.15fr) minmax(0, 0.95fr);
      gap: 12px;
    }

    @media (max-width: 840px) {
      main.board {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top left, rgba(15,23,42,0.95), rgba(15,23,42,1));
      border-radius: 18px;
      padding: 10px 10px 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 18px 40px rgba(0,0,0,0.9);
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 0.88rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tag {
      font-size: 0.7rem;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: var(--muted);
      background: rgba(15,23,42,0.96);
    }

    /* MAP */
    .map-wrapper {
      border-radius: 14px;
      padding: 6px;
      background:
        radial-gradient(circle at top, rgba(30,64,175,0.4), rgba(15,23,42,0.96));
      border: 1px solid rgba(30, 64, 175, 0.7);
    }

    #map {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 3px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 8px;
      background: var(--tile);
      border: 1px solid rgba(15,23,42,0.9);
      position: relative;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #e5e7eb;
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.9);
    }

    .tile.alt {
      background: var(--tile-alt);
    }

    .tile.player {
      box-shadow:
        0 0 0 2px rgba(129, 140, 248, 0.9),
        0 0 0 1px rgba(15,23,42,1),
        0 10px 18px rgba(37,99,235,0.7);
    }

    .tile.enemy {
      box-shadow:
        0 0 0 2px rgba(248, 113, 113, 0.95),
        0 0 0 1px rgba(15,23,42,1),
        0 10px 18px rgba(185,28,28,0.85);
    }

    .tile.item {
      box-shadow:
        0 0 0 2px rgba(52, 211, 153, 0.95),
        0 0 0 1px rgba(15,23,42,1),
        0 10px 18px rgba(16,185,129,0.8);
    }

    .tile.exit {
      box-shadow:
        0 0 0 2px rgba(250, 204, 21, 0.95),
        0 0 0 1px rgba(15,23,42,1),
        0 10px 18px rgba(202,138,4,0.85);
    }

    .legend {
      margin-top: 7px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-icon {
      width: 18px;
      height: 18px;
      border-radius: 5px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
    }

    .legend-icon.player {
      border-color: rgba(129, 140, 248, 0.9);
    }
    .legend-icon.enemy {
      border-color: rgba(248, 113, 113, 0.9);
    }
    .legend-icon.item {
      border-color: rgba(52, 211, 153, 0.95);
    }
    .legend-icon.exit {
      border-color: rgba(250, 204, 21, 0.95);
    }

    /* HUD / Question */
    .hud-top {
      display: grid;
      grid-template-columns: 1.15fr 0.85fr;
      gap: 8px;
      margin-bottom: 8px;
    }

    @media (max-width: 640px) {
      .hud-top {
        grid-template-columns: 1fr;
      }
    }

    .hud-card {
      border-radius: 12px;
      padding: 8px 9px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.45);
    }

    .hud-row {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      align-items: baseline;
      font-size: 0.8rem;
    }

    .hud-row strong {
      font-size: 0.9rem;
    }

    .hp-bar {
      margin-top: 6px;
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      overflow: hidden;
    }

    .hp-fill {
      height: 100%;
      width: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #22c55e, #a3e635, #facc15);
      transition: width 0.25s ease-out;
    }

    .hp-fill.low {
      background: linear-gradient(90deg, #f97373, #fb923c);
    }

    .question-box {
      margin-top: 3px;
      border-radius: 12px;
      padding: 8px 9px;
      background: rgba(2, 6, 23, 0.96);
      border: 1px dashed rgba(148, 163, 184, 0.6);
      font-size: 0.83rem;
    }

    .question-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--muted);
      margin-bottom: 4px;
    }

    #question-meaning {
      margin: 0 0 4px;
      font-size: 0.9rem;
    }

    #question-example {
      margin: 0;
      font-size: 0.78rem;
      color: var(--muted);
      font-style: italic;
    }

    .tiny-hint {
      margin-top: 4px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .answer-list {
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 5px;
    }

    .answer-btn {
      border: 1px solid rgba(148, 163, 184, 0.6);
      border-radius: 999px;
      padding: 6px 9px;
      font-size: 0.82rem;
      background: rgba(15, 23, 42, 0.96);
      color: var(--text);
      text-align: left;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
      transition:
        background 0.15s ease,
        border-color 0.15s ease,
        transform 0.12s ease,
        box-shadow 0.12s ease;
    }

    .answer-btn span.word {
      font-weight: 600;
    }

    .answer-btn:hover {
      background: rgba(30, 64, 175, 0.85);
      border-color: rgba(59, 130, 246, 0.9);
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.95);
    }

    .answer-btn.correct {
      background: rgba(22, 163, 74, 0.95);
      border-color: rgba(74, 222, 128, 0.95);
      color: #ecfdf5;
    }

    .answer-btn.wrong {
      background: rgba(248, 113, 113, 0.95);
      border-color: rgba(254, 202, 202, 0.95);
      color: #fef2f2;
    }

    .feedback {
      margin-top: 8px;
      font-size: 0.82rem;
      min-height: 18px;
    }

    .feedback.good {
      color: var(--success);
    }

    .feedback.bad {
      color: var(--danger);
    }

    .feedback span.highlight {
      font-weight: 600;
      color: #e5e7eb;
    }

    footer {
      margin-top: 9px;
      font-size: 0.75rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    footer span {
      opacity: 0.9;
    }

    /* Overlay khi Ä‘ang há»i */
    .question-active #map {
      filter: brightness(0.6) blur(1px);
      transition: filter 0.15s ease;
    }
  </style>
</head>
<body>
  <div class="game" id="game-root">
    <header>
      <div class="title-block">
        <div class="title-pill">Vocab Adventure Â· v2</div>
        <h1>ëª¬ìŠ¤í„° ì¡ê³  ì–´íœ˜ ëª¨ìœ¼ê¸° ğŸ§™â€â™€ï¸ğŸ‘¾â¤ï¸ğŸšª</h1>
        <p class="subtitle">
          í‚¤ë³´ë“œ <strong>â† â†‘ â†“ â†’</strong> ë˜ëŠ” <strong>W A S D</strong> ë¡œ ìºë¦­í„°ë¥¼ ì›€ì§ì´ì„¸ìš”.
          ğŸ‘¾ ëª¬ìŠ¤í„°ì™€ ë¶€ë”ªíˆë©´ ì–´íœ˜ ë¬¸ì œê°€ ë‚˜ì˜¤ê³ , â¤ï¸ ì•„ì´í…œì€ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤. ğŸšª ë¬¸ìœ¼ë¡œ ê°€ë©´ ë‹¤ìŒ ë ˆë²¨!
        </p>
      </div>
      <div class="controls">
        <div class="pill">
          âŒ¨ï¸ <span>ì¡°ì‘: â† â†‘ â†“ â†’ / W A S D</span>
        </div>
        <div class="pill">
          ğŸ¯ <span>ëª¬ìŠ¤í„° = ë¬¸ì œ, â¤ï¸ = ì²´ë ¥ íšŒë³µ</span>
        </div>
        <button id="restart-btn">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
    </header>

    <main class="board">
      <!-- MAP -->
      <section class="panel">
        <h2>
          ì–´íœ˜ ë§µ
          <span class="tag" id="level-label">ë ˆë²¨ 1</span>
        </h2>
        <div class="map-wrapper">
          <div id="map"></div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-icon player">ğŸ™‚</div> <span>í”Œë ˆì´ì–´</span>
          </div>
          <div class="legend-item">
            <div class="legend-icon enemy">ğŸ‘¾</div> <span>ì–´íœ˜ ë¬¸ì œê°€ ê±¸ë¦° ëª¬ìŠ¤í„°</span>
          </div>
          <div class="legend-item">
            <div class="legend-icon item">â¤ï¸</div> <span>ì²´ë ¥ +1 ì•„ì´í…œ</span>
          </div>
          <div class="legend-item">
            <div class="legend-icon exit">ğŸšª</div> <span>ë‹¤ìŒ ë ˆë²¨ë¡œ ê°€ëŠ” ë¬¸</span>
          </div>
        </div>
      </section>

      <!-- HUD / QUESTION -->
      <section class="panel">
        <h2>
          ìƒíƒœ & ë¬¸ì œ
          <span class="tag">ëª¬ìŠ¤í„° 1ë§ˆë¦¬ = ë‹¨ì–´ 1ê°œ</span>
        </h2>

        <div class="hud-top">
          <div class="hud-card">
            <div class="hud-row">
              <div>ìºë¦­í„°:</div>
              <strong id="player-name">ì–´íœ˜ ëª¨í—˜ê°€</strong>
            </div>
            <div class="hud-row" style="margin-top:4px;">
              <div>ì ìˆ˜:</div>
              <strong id="score-text">0</strong>
            </div>
            <div class="hud-row" style="margin-top:2px;">
              <div>ì²´ë ¥:</div>
              <strong id="hp-text">3 / 3</strong>
            </div>
            <div class="hp-bar">
              <div class="hp-fill" id="hp-fill"></div>
            </div>
            <div class="hud-row" style="margin-top:4px;">
              <div>ë‚¨ì€ ëª¬ìŠ¤í„°:</div>
              <strong id="enemies-left-text">0</strong>
            </div>
          </div>

          <div class="hud-card">
            <div class="hud-row">
              <div>í”Œë ˆì´ ë°©ë²•:</div>
            </div>
            <p class="tiny-hint" style="margin-top:6px;">
              â€¢ ë°©í–¥í‚¤ / WASD ë¡œ ì´ë™í•©ë‹ˆë‹¤.<br/>
              â€¢ ğŸ‘¾ ëª¬ìŠ¤í„°ì™€ ë¶€ë”ªíˆë©´: í•œêµ­ì–´ ëœ»ì„ ë³´ê³  ì•Œë§ì€ ì˜ì–´ ë‹¨ì–´ë¥¼ ê³ ë¥´ì„¸ìš”.<br/>
              â€¢ â¤ï¸ ë¥¼ ë¨¹ìœ¼ë©´ ì²´ë ¥ì´ 1 íšŒë³µë©ë‹ˆë‹¤ (ìµœëŒ€ 3).<br/>
              â€¢ ëª¨ë“  ëª¬ìŠ¤í„°ë¥¼ ì¡ìœ¼ë©´ ğŸšª ë¬¸ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. ë¬¸ìœ¼ë¡œ ë“¤ì–´ê°€ë©´ ë‹¤ìŒ ë ˆë²¨!
            </p>
          </div>
        </div>

        <div class="question-box">
          <div class="question-title">ì–´íœ˜ ë¬¸ì œ</div>
          <p id="question-meaning">ğŸ‘¾ ëª¬ìŠ¤í„° ì¹¸ìœ¼ë¡œ ì´ë™í•˜ë©´ ë¬¸ì œê°€ ì‹œì‘ë©ë‹ˆë‹¤!</p>
          <p id="question-example"></p>
          <p class="tiny-hint">
            íŒ: ë¨¼ì € <strong>í•œêµ­ì–´ ëœ»</strong>ì„ ë³´ê³ , ë¬¸ì¥ì€ ì‚¬ìš© ì˜ˆì‹œë¡œ ê°€ë³ê²Œ ì°¸ê³ í•˜ì„¸ìš”.
          </p>
          <div class="answer-list" id="answer-list">
            <!-- ë‹µì•ˆ ë²„íŠ¼ì´ ì—¬ê¸° ë Œë”ë§ë¨ -->
          </div>
        </div>

        <div id="feedback" class="feedback"></div>
      </section>
    </main>

    <footer>
      <span>ğŸ’¡ ë‹¨ì–´ ì„¸íŠ¸ë¥¼ ë°”ê¾¸ê³  ì‹¶ë‹¤ë©´ ì•„ë˜ ìŠ¤í¬ë¦½íŠ¸ì˜ <code>vocabulary</code> ë°°ì—´ì„ ìˆ˜ì •í•˜ì„¸ìš”.</span>
      <span>Prototype by you & ChatGPT â€“ í•œêµ­ íŒ€ë„ ê°™ì´ ì“¸ ìˆ˜ ìˆëŠ” ì–´íœ˜ ëª¨í—˜ ê²Œì„.</span>
    </footer>
  </div>

  <script>
    // ========== ì–´íœ˜ ë°ì´í„°: ì—¬ê¸°ì„œ ë‹¨ì–´/ëœ»/ì˜ˆë¬¸ ìˆ˜ì • ==========
    const vocabulary = [
      {
        id: 1,
        word: "negotiate",
        meaning: "í˜‘ìƒí•˜ë‹¤, êµì„­í•˜ë‹¤",
        example: "We need to negotiate a better price with the supplier."
      },
      {
        id: 2,
        word: "deadline",
        meaning: "ë§ˆê° ê¸°í•œ, ë°ë“œë¼ì¸",
        example: "The deadline for this project is next Monday."
      },
      {
        id: 3,
        word: "efficient",
        meaning: "íš¨ìœ¨ì ì¸ (ì‹œê°„Â·ë…¸ë ¥ì„ ì ê²Œ ì“°ëŠ”)",
        example: "This new method is much more efficient than the old one."
      },
      {
        id: 4,
        word: "reliable",
        meaning: "ë¯¿ì„ ë§Œí•œ, ì‹ ë¢°í•  ìˆ˜ ìˆëŠ”",
        example: "She is a reliable colleague who always finishes her tasks."
      },
      {
        id: 5,
        word: "persuade",
        meaning: "ì„¤ë“í•˜ë‹¤",
        example: "He managed to persuade his boss to accept the idea."
      },
      {
        id: 6,
        word: "exhausted",
        meaning: "ê¸°ì§„ë§¥ì§„í•œ, ë§¤ìš° í”¼ê³¤í•œ",
        example: "I felt exhausted after working all night."
      },
      {
        id: 7,
        word: "curious",
        meaning: "í˜¸ê¸°ì‹¬ì´ ë§ì€, ê¶ê¸ˆí•œ",
        example: "The child was very curious about how the machine worked."
      },
      {
        id: 8,
        word: "conference",
        meaning: "íšŒì˜, í•™íšŒ, ì»¨í¼ëŸ°ìŠ¤",
        example: "She is attending an international conference this week."
      },
      {
        id: 9,
        word: "priority",
        meaning: "ìš°ì„ ìˆœìœ„, ê°€ì¥ ì¤‘ìš”í•œ ê²ƒ",
        example: "Safety is our top priority."
      },
      {
        id: 10,
        word: "reschedule",
        meaning: "ì¼ì •ì„ ë³€ê²½í•˜ë‹¤, ë‹¤ì‹œ ì¡ë‹¤",
        example: "Can we reschedule the meeting to tomorrow afternoon?"
      }
    ];

    // ========== GAME STATE ==========
    const GRID_WIDTH = 10;
    const GRID_HEIGHT = 7;

    const player = {
      x: 0,
      y: 0,
      maxHp: 3,
      hp: 3,
      score: 0
    };

    let level = 1;
    let enemies = []; // {x,y, vocab, alive}
    let items = [];   // {x,y, heal}
    let exitDoor = { active: false, x: null, y: null };

    let isQuestionActive = false;
    let currentEnemy = null;
    let gameOver = false;

    // ========== UTILS ==========
    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }

    function pickRandomVocab(count) {
      const shuffled = shuffleArray(vocabulary);
      return shuffled.slice(0, Math.min(count, shuffled.length));
    }

    function samePos(a, b) {
      return a.x === b.x && a.y === b.y;
    }

    function randomEmptyPos() {
      while (true) {
        const pos = {
          x: Math.floor(Math.random() * GRID_WIDTH),
          y: Math.floor(Math.random() * GRID_HEIGHT)
        };
        const overlapPlayer = samePos(pos, player);
        const overlapEnemy = enemies.some((e) => e.alive && samePos(e, pos));
        const overlapItem = items.some((it) => samePos(it, pos));
        const overlapExit = exitDoor.active && samePos(pos, exitDoor);
        if (!overlapPlayer && !overlapEnemy && !overlapItem && !overlapExit) {
          return pos;
        }
      }
    }

    // ========== GAME SETUP ==========
    function startGame() {
      player.x = 0;
      player.y = Math.floor(GRID_HEIGHT / 2);
      player.maxHp = 3;
      player.hp = 3;
      player.score = 0;

      level = 1;
      gameOver = false;
      isQuestionActive = false;
      currentEnemy = null;
      enemies = [];
      items = [];
      exitDoor = { active: false, x: null, y: null };

      document.getElementById("game-root").classList.remove("question-active");
      spawnEnemiesForLevel();
      spawnItemsForLevel();

      updateUI();
      renderMap();
      setFeedback("ğŸ‘¾ ëª¬ìŠ¤í„° ìª½ìœ¼ë¡œ ì´ë™í•´ì„œ ì²« ë²ˆì§¸ ì–´íœ˜ ë¬¸ì œë¥¼ í’€ì–´ ë³´ì„¸ìš”!", "");
      toggleRestart(false);
    }

    function spawnEnemiesForLevel() {
      enemies = [];
      const enemyCount = clamp(2 + level, 2, 6); // ì¦ê°€, ìµœëŒ€ 6
      const chosenVocab = pickRandomVocab(enemyCount);

      for (let i = 0; i < chosenVocab.length; i++) {
        let pos;
        while (true) {
          pos = {
            x: Math.floor(Math.random() * GRID_WIDTH),
            y: Math.floor(Math.random() * GRID_HEIGHT)
          };
          const overlapPlayer = samePos(pos, player);
          const overlapEnemy = enemies.some((e) => samePos(e, pos));
          if (!overlapPlayer && !overlapEnemy) break;
        }
        enemies.push({
          x: pos.x,
          y: pos.y,
          vocab: chosenVocab[i],
          alive: true
        });
      }
    }

    function spawnItemsForLevel() {
      items = [];
      const itemCount = clamp(1 + Math.floor(level / 2), 1, 4);
      for (let i = 0; i < itemCount; i++) {
        const pos = randomEmptyPos();
        items.push({
          x: pos.x,
          y: pos.y,
          heal: 1
        });
      }
    }

    function spawnExitDoor() {
      exitDoor.active = true;
      const pos = randomEmptyPos();
      exitDoor.x = pos.x;
      exitDoor.y = pos.y;
      setFeedback(
        `âœ… ëª¨ë“  ëª¬ìŠ¤í„°ë¥¼ ë¬¼ë¦¬ì³¤ìŠµë‹ˆë‹¤! ë§µ ì–´ë”˜ê°€ì— <span class="highlight">ğŸšª ì¶œêµ¬</span>ê°€ ì—´ë ¸ì–´ìš”. ê·¸ ë¬¸ìœ¼ë¡œ ê°€ë©´ ë ˆë²¨ ${level + 1}(ìœ¼)ë¡œ ì´ë™í•©ë‹ˆë‹¤.`,
        "good"
      );
      renderMap();
      updateUI();
    }

    // ========== MAP RENDER ==========
    function renderMap() {
      const mapEl = document.getElementById("map");
      mapEl.innerHTML = "";
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          const tileEl = document.createElement("div");
          tileEl.className = "tile";
          if ((x + y) % 2 === 1) tileEl.classList.add("alt");

          let content = "";
          const enemyHere = enemies.find((e) => e.alive && e.x === x && e.y === y);
          const itemHere = items.find((it) => it.x === x && it.y === y);
          const exitHere = exitDoor.active && exitDoor.x === x && exitDoor.y === y;

          if (player.x === x && player.y === y) {
            tileEl.classList.add("player");
            content = "ğŸ™‚";
          } else if (enemyHere) {
            tileEl.classList.add("enemy");
            content = "ğŸ‘¾";
          } else if (exitHere) {
            tileEl.classList.add("exit");
            content = "ğŸšª";
          } else if (itemHere) {
            tileEl.classList.add("item");
            content = "â¤ï¸";
          }

          tileEl.textContent = content;
          mapEl.appendChild(tileEl);
        }
      }
    }

    // ========== MOVEMENT ==========
    function tryMove(dx, dy) {
      if (isQuestionActive || gameOver) return;

      const newX = clamp(player.x + dx, 0, GRID_WIDTH - 1);
      const newY = clamp(player.y + dy, 0, GRID_HEIGHT - 1);

      player.x = newX;
      player.y = newY;

      // ëª¬ìŠ¤í„° ì¶©ëŒ ì²´í¬
      const enemy = enemies.find((e) => e.alive && samePos(e, player));
      if (enemy) {
        triggerQuestion(enemy);
        renderMap();
        updateUI();
        return;
      }

      // íšŒë³µ ì•„ì´í…œ ì²´í¬
      const itemIndex = items.findIndex((it) => samePos(it, player));
      if (itemIndex !== -1) {
        const item = items[itemIndex];
        items.splice(itemIndex, 1);
        const beforeHp = player.hp;
        player.hp = clamp(player.hp + item.heal, 0, player.maxHp);
        const healed = player.hp - beforeHp;
        if (healed > 0) {
          setFeedback(
            `â¤ï¸ íšŒë³µ ì•„ì´í…œì„ ë¨¹ì—ˆìŠµë‹ˆë‹¤! ì²´ë ¥ <span class="highlight">${healed} HP</span> íšŒë³µ.`,
            "good"
          );
        } else {
          setFeedback(`ì´ë¯¸ ì²´ë ¥ì´ ê°€ë“ ì°¨ ìˆì–´ì„œ ë” ì´ìƒ íšŒë³µë˜ì§€ ì•Šì•„ìš” ğŸ˜†`, "");
        }
      }

      // ì¶œêµ¬ ë¬¸ ì²´í¬
      if (exitDoor.active && samePos(player, exitDoor)) {
        handleLevelCompleted();
        return;
      }

      renderMap();
      updateUI();
    }

    // ========== QUESTION SYSTEM ==========
    function triggerQuestion(enemy) {
      isQuestionActive = true;
      currentEnemy = enemy;
      document.getElementById("game-root").classList.add("question-active");

      const meaningEl = document.getElementById("question-meaning");
      const exampleEl = document.getElementById("question-example");
      const answerList = document.getElementById("answer-list");
      answerList.innerHTML = "";

      meaningEl.textContent = enemy.vocab.meaning;
      exampleEl.textContent = "ì˜ˆë¬¸: " + enemy.vocab.example;

      // ì„ íƒì§€: ì •ë‹µ 1ê°œ + ì˜¤ë‹µ 3ê°œ
      const otherVocab = shuffleArray(
        vocabulary.filter((v) => v.word !== enemy.vocab.word)
      ).slice(0, 3);

      const options = shuffleArray([enemy.vocab, ...otherVocab]);

      options.forEach((opt, index) => {
        const btn = document.createElement("button");
        btn.className = "answer-btn";
        btn.innerHTML = `<span class="word">${opt.word}</span>
          <span style="opacity:0.7;">${String.fromCharCode(65 + index)}</span>`;
        btn.addEventListener("click", () => handleAnswerClick(btn, opt.word));
        answerList.appendChild(btn);
      });

      setFeedback("ëœ»ì— ë§ëŠ” ì˜ì–´ ë‹¨ì–´ë¥¼ ê³¨ë¼ ë³´ì„¸ìš”!", "");
    }

    function handleAnswerClick(buttonEl, chosenWord) {
      if (!isQuestionActive || !currentEnemy || gameOver) return;

      const answerButtons = document.querySelectorAll(".answer-btn");
      answerButtons.forEach((btn) => (btn.disabled = true));

      const correctWord = currentEnemy.vocab.word;
      const isCorrect = chosenWord === correctWord;

      if (isCorrect) {
        buttonEl.classList.add("correct");
        player.score += 10 + 5 * level;
        currentEnemy.alive = false;
        setFeedback(
          `ì •ë‹µ! <span class="highlight">${correctWord}</span> ë‹¨ì–´ë¡œ ëª¬ìŠ¤í„°ë¥¼ ë¬¼ë¦¬ì³¤ìŠµë‹ˆë‹¤.`,
          "good"
        );
      } else {
        buttonEl.classList.add("wrong");
        const correctBtn = Array.from(answerButtons).find((btn) =>
          btn.textContent.includes(correctWord)
        );
        if (correctBtn) correctBtn.classList.add("correct");

        player.hp = clamp(player.hp - 1, 0, player.maxHp);
        setFeedback(
          `ì•„ì‰½ë„¤ìš” ğŸ˜¢ ì •ë‹µì€ <span class="highlight">${correctWord}</span> ì…ë‹ˆë‹¤. ì²´ë ¥ 1 ê°ì†Œ.`,
          "bad"
        );
        if (player.hp <= 0) {
          handleGameOver();
        }
      }

      updateUI();

      // ì ê¹ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì§ˆë¬¸ ì°½ ë‹«ê¸°
      setTimeout(() => {
        if (!gameOver) {
          isQuestionActive = false;
          currentEnemy = null;
          document.getElementById("game-root").classList.remove("question-active");
          document.getElementById("answer-list").innerHTML = "";

          const remaining = enemies.filter((e) => e.alive).length;
          if (remaining === 0) {
            if (!exitDoor.active) {
              spawnExitDoor();
            }
          } else {
            setFeedback("ë‹¤ë¥¸ ëª¬ìŠ¤í„°ë¥¼ ì°¾ì•„ ê³„ì† ì´ë™í•´ ë³´ì„¸ìš”!", "");
          }
        }
        renderMap();
        updateUI();
      }, 900);
    }

    function handleLevelCompleted() {
      level += 1;
      exitDoor = { active: false, x: null, y: null };
      enemies = [];
      items = [];

      setFeedback(
        `ğŸ‰ ì¶œêµ¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤! ë ˆë²¨ <span class="highlight">${level}</span>(ìœ¼)ë¡œ ì§„ê¸‰í–ˆìŠµë‹ˆë‹¤. ë” ë§ì€ ëª¬ìŠ¤í„°ì™€ ë‹¨ì–´ê°€ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”.`,
        "good"
      );

      spawnEnemiesForLevel();
      spawnItemsForLevel();
      renderMap();
      updateUI();
    }

    function handleGameOver() {
      gameOver = true;
      isQuestionActive = false;
      document.getElementById("game-root").classList.remove("question-active");
      document.getElementById("answer-list").innerHTML = "";
      document.getElementById("question-meaning").textContent =
        "ëª¨í—˜ ë„ì¤‘ì— ì“°ëŸ¬ì§€ê³  ë§ì•˜ìŠµë‹ˆë‹¤â€¦";
      document.getElementById("question-example").textContent = "";
      setFeedback(
        `Game Over ğŸ’€ ìµœì¢… ì ìˆ˜: <span class="highlight">${player.score}</span>. "ë‹¤ì‹œ ì‹œì‘"ì„ ëˆŒëŸ¬ ìƒˆë¡œìš´ ëª¨í—˜ì„ ì‹œì‘í•´ ë³´ì„¸ìš”.`,
        "bad"
      );
      toggleRestart(true);
      renderMap();
      updateUI();
    }

    // ========== UI ==========
    function updateUI() {
      document.getElementById("player-name").textContent = "ì–´íœ˜ ëª¨í—˜ê°€";
      document.getElementById("score-text").textContent = player.score;
      document.getElementById("hp-text").textContent = `${player.hp} / ${player.maxHp}`;

      const hpFill = document.getElementById("hp-fill");
      const hpPercent = (player.hp / player.maxHp) * 100;
      hpFill.style.width = `${hpPercent}%`;
      if (hpPercent <= 34) {
        hpFill.classList.add("low");
      } else {
        hpFill.classList.remove("low");
      }

      const enemiesLeft = enemies.filter((e) => e.alive).length;
      document.getElementById("enemies-left-text").textContent = enemiesLeft;
      document.getElementById("level-label").textContent = `ë ˆë²¨ ${level}`;
    }

    function setFeedback(message, type) {
      const el = document.getElementById("feedback");
      el.className = "feedback";
      if (type === "good") el.classList.add("good");
      if (type === "bad") el.classList.add("bad");
      el.innerHTML = message;
    }

    function toggleRestart(show) {
      const btn = document.getElementById("restart-btn");
      btn.style.display = show ? "inline-flex" : "none";
    }

    // ========== INPUT ==========
    function handleKeyDown(e) {
      const key = e.key.toLowerCase();
      let dx = 0;
      let dy = 0;
      if (key === "arrowup" || key === "w") dy = -1;
      else if (key === "arrowdown" || key === "s") dy = 1;
      else if (key === "arrowleft" || key === "a") dx = -1;
      else if (key === "arrowright" || key === "d") dx = 1;
      else return;

      e.preventDefault();
      tryMove(dx, dy);
    }

    // ========== INIT ==========
    document.addEventListener("DOMContentLoaded", () => {
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("restart-btn").addEventListener("click", startGame);
      startGame();
    });
  </script>
</body>
</html>
